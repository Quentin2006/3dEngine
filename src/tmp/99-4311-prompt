<DIRECTIONS>
add comments
</DIRECTIONS>
<Context>
You receive a selection in neovim that you need to replace with new code.
The selection's contents may contain notes, incorporate the notes every time if there are some.
consider the context of the selection and what you are suppose to be implementing
<SELECTION_LOCATION>
range(point(51,1),point(104,6))
</SELECTION_LOCATION>
<SELECTION_CONTENT>
    auto &parametricOpt = reg.getParametricAnimator(i);
    if (parametricOpt.has_value()) {
      auto &anim = parametricOpt.value();
      const auto &pts = anim.points;

      if (pts.size() >= 2) {
        bool cyclic = glm::length(pts.front() - pts.back()) < 0.001f;
        int numSegments = (int)pts.size() - 1;

        // totalTime * speed gives us how far along the path we are
        float globalT = std::fmod(totalTime * anim.speed +
                                      numSegments * parametricOpt->phase,
                                  numSegments);
        if (globalT < 0.0f)
          globalT += (float)numSegments;

        int seg = (int)globalT;
        float localT = globalT - (float)seg;

        if (seg >= numSegments) {
          seg = numSegments - 1;
          localT = 1.0f;
        }

        glm::vec3 p0, p1, p2, p3;
        if (cyclic) {
          int n = numSegments;
          p0 = pts[((seg - 1) % n + n) % n];
          p1 = pts[seg % n];
          p2 = pts[(seg + 1) % n];
          p3 = pts[(seg + 2) % n];
        } else {
          int n = (int)pts.size();
          p0 = pts[std::max(seg - 1, 0)];
          p1 = pts[seg];
          p2 = pts[std::min(seg + 1, n - 1)];
          p3 = pts[std::min(seg + 2, n - 1)];
        }

        auto &t = reg.getTransform(i);
        t.position = spline::catmullRom(p0, p1, p2, p3, localT);

        // Compute tangent for orientation (face direction of travel)
        glm::vec3 tangent = spline::catmullRomTangent(p0, p1, p2, p3, localT);
        tangent = glm::normalize(tangent);

        // Convert tangent to yaw/pitch rotation
        float yaw = glm::degrees(std::atan2(-tangent.z, tangent.x));
        float pitch =
            glm::degrees(std::asin(glm::clamp(tangent.y, -1.0f, 1.0f)));

        t.rotation = {pitch, yaw, 0.0f};
      }
    }
</SELECTION_CONTENT>
<FILE_CONTAINING_SELECTION>
#pragma once
#include "../../include/glad/glad.h"
#include "../math/spline.h"
#include "../mesh.h"
#include "registry.h"
#include <cmath>
#include <glm/ext/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>

inline void updateTransforms(Registry &reg) {
  for (auto &t : reg.allTransforms()) {
    t.matrix = glm::mat4(1.0f);
    t.matrix = glm::translate(t.matrix, t.position);
    t.matrix =
        glm::rotate(t.matrix, glm::radians(t.rotation.x), glm::vec3(1, 0, 0));
    t.matrix =
        glm::rotate(t.matrix, glm::radians(t.rotation.y), glm::vec3(0, 1, 0));
    t.matrix =
        glm::rotate(t.matrix, glm::radians(t.rotation.z), glm::vec3(0, 0, 1));
    t.matrix = glm::scale(t.matrix, t.scale);

    if (t.parrentId >= 0) {
      auto &parrentTranform = reg.getTransform(t.parrentId);
      t.matrix = parrentTranform.matrix * t.matrix;
    }
  }
}

inline void updateAnimations(Registry &reg, float deltaTime) {
  static float totalTime = 0;
  totalTime += deltaTime;
  for (size_t i = 0; i < reg.entityCount(); i++) {
    // NOTE: CHECK SINE ANIMATOR
    auto &sineOpt = reg.getSineAnimator(i);
    if (sineOpt.has_value()) {
      auto &anim = sineOpt.value();
      auto &t = reg.getTransform(i);
      float offset =
          sin(totalTime * anim.frequency + anim.phase) * anim.amplitude;
      t.position += anim.axis * offset;
    }
    // NOTE: CHECK ROTATION ANIMATOR
    auto &rotOpt = reg.getRotationAnimator(i);
    if (rotOpt.has_value()) {
      auto &anim = rotOpt.value();
      auto &t = reg.getTransform(i);
      t.rotation += anim.axis * anim.rpm * 6.0f * deltaTime;
    }
    // NOTE: CHECK PARAMETRIC ANIMATOR
    auto &parametricOpt = reg.getParametricAnimator(i);
    if (parametricOpt.has_value()) {
      auto &anim = parametricOpt.value();
      const auto &pts = anim.points;

      if (pts.size() >= 2) {
        bool cyclic = glm::length(pts.front() - pts.back()) < 0.001f;
        int numSegments = (int)pts.size() - 1;

        // totalTime * speed gives us how far along the path we are
        float globalT = std::fmod(totalTime * anim.speed +
                                      numSegments * parametricOpt->phase,
                                  numSegments);
        if (globalT < 0.0f)
          globalT += (float)numSegments;

        int seg = (int)globalT;
        float localT = globalT - (float)seg;

        if (seg >= numSegments) {
          seg = numSegments - 1;
          localT = 1.0f;
        }

        glm::vec3 p0, p1, p2, p3;
        if (cyclic) {
          int n = numSegments;
          p0 = pts[((seg - 1) % n + n) % n];
          p1 = pts[seg % n];
          p2 = pts[(seg + 1) % n];
          p3 = pts[(seg + 2) % n];
        } else {
          int n = (int)pts.size();
          p0 = pts[std::max(seg - 1, 0)];
          p1 = pts[seg];
          p2 = pts[std::min(seg + 1, n - 1)];
          p3 = pts[std::min(seg + 2, n - 1)];
        }

        auto &t = reg.getTransform(i);
        t.position = spline::catmullRom(p0, p1, p2, p3, localT);

        // Compute tangent for orientation (face direction of travel)
        glm::vec3 tangent = spline::catmullRomTangent(p0, p1, p2, p3, localT);
        tangent = glm::normalize(tangent);

        // Convert tangent to yaw/pitch rotation
        float yaw = glm::degrees(std::atan2(-tangent.z, tangent.x));
        float pitch =
            glm::degrees(std::asin(glm::clamp(tangent.y, -1.0f, 1.0f)));

        t.rotation = {pitch, yaw, 0.0f};
      }
    }
  }
}

inline void renderAll(Registry &reg, GLuint modelUniform, GLint diffuseTexUnit,
                      GLint specularTexUnit, GLuint shininessLoc) {

  for (size_t i = 0; i < reg.entityCount(); i++) {
    auto &meshComp = reg.getMesh(i);
    if (meshComp.mesh) {
      glUniformMatrix4fv(modelUniform, 1, GL_FALSE,
                         glm::value_ptr(reg.getTransform(i).matrix));

      // Set texture units for specular lighting
      glUniform1i(diffuseTexUnit, 0);  // diffuse texture to unit 0
      glUniform1i(specularTexUnit, 1); // specular texture to unit 1
      glUniform1f(shininessLoc, meshComp.mesh->getShininess());

      meshComp.mesh->draw();
    }
  }
}
</FILE_CONTAINING_SELECTION>

</Context>

<Location><File>/home/qscheetz/Documents/3dEngine/src/ecs/systems.h</File><Function>range(point(51,1),point(104,6))</Function></Location>
<FunctionText>    auto &parametricOpt = reg.getParametricAnimator(i);
    if (parametricOpt.has_value()) {
      auto &anim = parametricOpt.value();
      const auto &pts = anim.points;

      if (pts.size() >= 2) {
        bool cyclic = glm::length(pts.front() - pts.back()) < 0.001f;
        int numSegments = (int)pts.size() - 1;

        // totalTime * speed gives us how far along the path we are
        float globalT = std::fmod(totalTime * anim.speed +
                                      numSegments * parametricOpt->phase,
                                  numSegments);
        if (globalT < 0.0f)
          globalT += (float)numSegments;

        int seg = (int)globalT;
        float localT = globalT - (float)seg;

        if (seg >= numSegments) {
          seg = numSegments - 1;
          localT = 1.0f;
        }

        glm::vec3 p0, p1, p2, p3;
        if (cyclic) {
          int n = numSegments;
          p0 = pts[((seg - 1) % n + n) % n];
          p1 = pts[seg % n];
          p2 = pts[(seg + 1) % n];
          p3 = pts[(seg + 2) % n];
        } else {
          int n = (int)pts.size();
          p0 = pts[std::max(seg - 1, 0)];
          p1 = pts[seg];
          p2 = pts[std::min(seg + 1, n - 1)];
          p3 = pts[std::min(seg + 2, n - 1)];
        }

        auto &t = reg.getTransform(i);
        t.position = spline::catmullRom(p0, p1, p2, p3, localT);

        // Compute tangent for orientation (face direction of travel)
        glm::vec3 tangent = spline::catmullRomTangent(p0, p1, p2, p3, localT);
        tangent = glm::normalize(tangent);

        // Convert tangent to yaw/pitch rotation
        float yaw = glm::degrees(std::atan2(-tangent.z, tangent.x));
        float pitch =
            glm::degrees(std::asin(glm::clamp(tangent.y, -1.0f, 1.0f)));

        t.rotation = {pitch, yaw, 0.0f};
      }
    }</FunctionText>
<MustObey>
NEVER alter any file other than TEMP_FILE.
never provide the requested changes as conversational output. Return only the code.
ONLY provide requested changes by writing the change to TEMP_FILE

never attempt to read TEMP_FILE.
It is purely for output.
Previous contents, which may not exist, can be written over without worry
After writing TEMP_FILE once you should be done.  Be done and end the session.

</MustObey>
<TEMP_FILE>./tmp/99-4311</TEMP_FILE>