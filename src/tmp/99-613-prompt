<DIRECTIONS>
add coments to each fucntion describing the input and output
</DIRECTIONS>
<Context>
You receive a selection in neovim that you need to replace with new code.
The selection's contents may contain notes, incorporate the notes every time if there are some.
consider the context of the selection and what you are suppose to be implementing
<SELECTION_LOCATION>
range(point(1,1),point(75,2))
</SELECTION_LOCATION>
<SELECTION_CONTENT>
#pragma once
#include <algorithm>
#include <glm/glm.hpp>
#include <vector>

// Evaluate the tangent (first derivative) of Catmull-Rom at parameter t
inline glm::vec3 catmullRomTangent(const glm::vec3 &p0, const glm::vec3 &p1,
                                   const glm::vec3 &p2, const glm::vec3 &p3,
                                   float t) {
  float t2 = t * t;
  return 0.5f *
         ((-p0 + p2) + (4.0f * p0 - 10.0f * p1 + 8.0f * p2 - 2.0f * p3) * t +
          (-3.0f * p0 + 9.0f * p1 - 9.0f * p2 + 3.0f * p3) * t2);
}

// Evaluate Catmull-Rom spline at parameter t for 4 control points
// t in [0, 1], curve passes through p1 (at t=0) and p2 (at t=1)
inline glm::vec3 catmullRom(const glm::vec3 &p0, const glm::vec3 &p1,
                            const glm::vec3 &p2, const glm::vec3 &p3, float t) {
  float t2 = t * t;
  float t3 = t2 * t;
  return 0.5f * ((2.0f * p1) + (-p0 + p2) * t +
                 (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +
                 (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);
}

// Subdivide a set of control points into `totalSamples` smooth points.
// If cyclic is true, the spline wraps around (first/last point should match).
inline std::vector<glm::vec3> subdivide(const std::vector<glm::vec3> &points,
                                        int totalSamples, bool cyclic = false) {
  std::vector<glm::vec3> result;
  result.reserve(totalSamples);

  if (points.size() < 2)
    return points;

  int numSegments = (int)points.size() - 1;

  for (int i = 0; i < totalSamples; ++i) {
    float globalT = (float)i / (float)totalSamples * (float)numSegments;
    int seg = (int)globalT;
    float localT = globalT - (float)seg;

    // Clamp segment index
    if (seg >= numSegments) {
      seg = numSegments - 1;
      localT = 1.0f;
    }

    // Get the 4 control points for this segment
    glm::vec3 p0, p1, p2, p3;
    if (cyclic) {
      int n = numSegments; // number of unique points (last == first)
      p0 = points[((seg - 1) % n + n) % n];
      p1 = points[seg % n];
      p2 = points[(seg + 1) % n];
      p3 = points[(seg + 2) % n];
    } else {
      int n = (int)points.size();
      p0 = points[std::max(seg - 1, 0)];
      p1 = points[seg];
      p2 = points[std::min(seg + 1, n - 1)];
      p3 = points[std::min(seg + 2, n - 1)];
    }

    result.push_back(catmullRom(p0, p1, p2, p3, localT));
  }

  // For cyclic paths, close the loop
  if (cyclic) {
    result.push_back(result.front());
  }

  return result;
}
</SELECTION_CONTENT>
<FILE_CONTAINING_SELECTION>
#pragma once
#include <algorithm>
#include <glm/glm.hpp>
#include <vector>

// Evaluate the tangent (first derivative) of Catmull-Rom at parameter t
inline glm::vec3 catmullRomTangent(const glm::vec3 &p0, const glm::vec3 &p1,
                                   const glm::vec3 &p2, const glm::vec3 &p3,
                                   float t) {
  float t2 = t * t;
  return 0.5f *
         ((-p0 + p2) + (4.0f * p0 - 10.0f * p1 + 8.0f * p2 - 2.0f * p3) * t +
          (-3.0f * p0 + 9.0f * p1 - 9.0f * p2 + 3.0f * p3) * t2);
}

// Evaluate Catmull-Rom spline at parameter t for 4 control points
// t in [0, 1], curve passes through p1 (at t=0) and p2 (at t=1)
inline glm::vec3 catmullRom(const glm::vec3 &p0, const glm::vec3 &p1,
                            const glm::vec3 &p2, const glm::vec3 &p3, float t) {
  float t2 = t * t;
  float t3 = t2 * t;
  return 0.5f * ((2.0f * p1) + (-p0 + p2) * t +
                 (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +
                 (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);
}

// Subdivide a set of control points into `totalSamples` smooth points.
// If cyclic is true, the spline wraps around (first/last point should match).
inline std::vector<glm::vec3> subdivide(const std::vector<glm::vec3> &points,
                                        int totalSamples, bool cyclic = false) {
  std::vector<glm::vec3> result;
  result.reserve(totalSamples);

  if (points.size() < 2)
    return points;

  int numSegments = (int)points.size() - 1;

  for (int i = 0; i < totalSamples; ++i) {
    float globalT = (float)i / (float)totalSamples * (float)numSegments;
    int seg = (int)globalT;
    float localT = globalT - (float)seg;

    // Clamp segment index
    if (seg >= numSegments) {
      seg = numSegments - 1;
      localT = 1.0f;
    }

    // Get the 4 control points for this segment
    glm::vec3 p0, p1, p2, p3;
    if (cyclic) {
      int n = numSegments; // number of unique points (last == first)
      p0 = points[((seg - 1) % n + n) % n];
      p1 = points[seg % n];
      p2 = points[(seg + 1) % n];
      p3 = points[(seg + 2) % n];
    } else {
      int n = (int)points.size();
      p0 = points[std::max(seg - 1, 0)];
      p1 = points[seg];
      p2 = points[std::min(seg + 1, n - 1)];
      p3 = points[std::min(seg + 2, n - 1)];
    }

    result.push_back(catmullRom(p0, p1, p2, p3, localT));
  }

  // For cyclic paths, close the loop
  if (cyclic) {
    result.push_back(result.front());
  }

  return result;
}
</FILE_CONTAINING_SELECTION>

</Context>

<Location><File>/home/qscheetz/Documents/3dEngine/src/math/spline.h</File><Function>range(point(1,1),point(75,2))</Function></Location>
<FunctionText>#pragma once
#include <algorithm>
#include <glm/glm.hpp>
#include <vector>

// Evaluate the tangent (first derivative) of Catmull-Rom at parameter t
inline glm::vec3 catmullRomTangent(const glm::vec3 &p0, const glm::vec3 &p1,
                                   const glm::vec3 &p2, const glm::vec3 &p3,
                                   float t) {
  float t2 = t * t;
  return 0.5f *
         ((-p0 + p2) + (4.0f * p0 - 10.0f * p1 + 8.0f * p2 - 2.0f * p3) * t +
          (-3.0f * p0 + 9.0f * p1 - 9.0f * p2 + 3.0f * p3) * t2);
}

// Evaluate Catmull-Rom spline at parameter t for 4 control points
// t in [0, 1], curve passes through p1 (at t=0) and p2 (at t=1)
inline glm::vec3 catmullRom(const glm::vec3 &p0, const glm::vec3 &p1,
                            const glm::vec3 &p2, const glm::vec3 &p3, float t) {
  float t2 = t * t;
  float t3 = t2 * t;
  return 0.5f * ((2.0f * p1) + (-p0 + p2) * t +
                 (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +
                 (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);
}

// Subdivide a set of control points into `totalSamples` smooth points.
// If cyclic is true, the spline wraps around (first/last point should match).
inline std::vector<glm::vec3> subdivide(const std::vector<glm::vec3> &points,
                                        int totalSamples, bool cyclic = false) {
  std::vector<glm::vec3> result;
  result.reserve(totalSamples);

  if (points.size() < 2)
    return points;

  int numSegments = (int)points.size() - 1;

  for (int i = 0; i < totalSamples; ++i) {
    float globalT = (float)i / (float)totalSamples * (float)numSegments;
    int seg = (int)globalT;
    float localT = globalT - (float)seg;

    // Clamp segment index
    if (seg >= numSegments) {
      seg = numSegments - 1;
      localT = 1.0f;
    }

    // Get the 4 control points for this segment
    glm::vec3 p0, p1, p2, p3;
    if (cyclic) {
      int n = numSegments; // number of unique points (last == first)
      p0 = points[((seg - 1) % n + n) % n];
      p1 = points[seg % n];
      p2 = points[(seg + 1) % n];
      p3 = points[(seg + 2) % n];
    } else {
      int n = (int)points.size();
      p0 = points[std::max(seg - 1, 0)];
      p1 = points[seg];
      p2 = points[std::min(seg + 1, n - 1)];
      p3 = points[std::min(seg + 2, n - 1)];
    }

    result.push_back(catmullRom(p0, p1, p2, p3, localT));
  }

  // For cyclic paths, close the loop
  if (cyclic) {
    result.push_back(result.front());
  }

  return result;
}</FunctionText>
<MustObey>
NEVER alter any file other than TEMP_FILE.
never provide the requested changes as conversational output. Return only the code.
ONLY provide requested changes by writing the change to TEMP_FILE

never attempt to read TEMP_FILE.
It is purely for output.
Previous contents, which may not exist, can be written over without worry
After writing TEMP_FILE once you should be done.  Be done and end the session.

</MustObey>
<TEMP_FILE>./tmp/99-613</TEMP_FILE>